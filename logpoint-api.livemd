<!-- livebook:{"app_settings":{"access_type":"public","auto_shutdown_ms":3600000,"slug":"logpoint-api"}} -->

# Logpoint API

```elixir
Mix.install(
  [
    {:kino, "~> 0.14.2"},
    {:logpoint, github: "MikaelFangel/logpoint_api", branch: "v1"}
  ],
  consolidate_protocols: false
)
```

## Search API

This is the Logpoint API for creating searches and retrieve the results, but also the API that can give information about Logpoint instances.

```elixir
ip_input = Kino.Input.text("Logpoint Instance IP")
username_input = Kino.Input.text("Logpoint Username")
secret_key_input = Kino.Input.text("Secret Key Env. Var")

Kino.render(ip_input)
Kino.render(username_input)
Kino.render(secret_key_input)

ip = Kino.Input.read(ip_input)
username = Kino.Input.read(username_input)
secret_key = Kino.Input.read(secret_key_input)

"Form Rendered"
```

```elixir
Logpoint.start_supervisor()
{:ok, pid} = Logpoint.new(ip, username, System.fetch_env!(secret_key))

IO.puts("Access variables set.")
```

<!-- livebook:{"branch_parent_index":0} -->

## getalloweddata

This gives access to information about a Logpoint instance and all the data available to it. Furthermore it can retrieve information related to the live searches used by a particular instance.

<!-- livebook:{"break_markdown":true} -->

### Getting User Timezone

This will retrieve the timezone and time format.

```elixir
{_, result} = Logpoint.user_preference(pid)

Kino.DataTable.new([result])
```

### Getting Logpoints

This retrieves the names and IP addresses of all the Logpoints configured in a distributed setup.

```elixir
{_, result} = Logpoint.loginspects(pid)
result
|> Map.get("allowed_loginspects")
|> Kino.DataTable.new()
```

### Getting Repos

This retrieves the name and IP addresses of all the repos configured in a Logpoint instance.

```elixir
{_, result} = Logpoint.logpoint_repos(pid)

result
|> Map.get("allowed_repos")
|> Kino.DataTable.new()
```

### Getting Devices

This retrieves all the names and IP addresses of all the devices configured in a Logpoint instance.

```elixir
{_, result} = Logpoint.devices(pid)

Map.get(result, "allowed_devices")
|> hd
|> Enum.map(fn {key, value} -> %{"name" => value, "ip" => key} end)
|> Kino.DataTable.new()
```

### Getting LiveSearches

This retrieves the information related to the live searches performed for dashboards and alerts.

```elixir
{_, result} = Logpoint.livesearches(pid)

Map.get(result, "livesearches")
|> Kino.Tree.new()
```

<!-- livebook:{"branch_parent_index":0} -->

## getsearchlogs

### Requesting a Search ID

Before we can retrieve results we need to create a search. By creating a search we will receive a search id, which can be used to retrieve the results. The search id is temporary and will be forgotten after some time and if retrieved to early it will return final = false.

```elixir
query = Kino.Input.text("Logpoint Query")
```

```elixir
request_data = Logpoint.Api.Query.new(
  Kino.Input.read(query),
  "Last 24 hours",
  100_000,
  ["127.0.0.1:5504/Network"]
)

{:ok, search_id} = Logpoint.submit_search(pid, request_data)
```

### Get the status of a submitted search

```elixir
Logpoint.search_status(pid, search_id)
```

```elixir
Logpoint.searches(pid, :complete)
```

### Getting search results

```elixir
{_, result} = Logpoint.search_result(pid, search_id)
```

```elixir
rows = Map.get(result, "rows")

all_keys =
  rows
  |> Enum.map(&Map.keys/1)
  |> Enum.map(&MapSet.new/1)
  |> Enum.reduce(MapSet.new(), &MapSet.union(&2, &1))

normalized_maps =
  rows
  |> Enum.map(fn map ->
    Enum.reduce(all_keys, map, fn key, acc ->
      Map.put_new(acc, key, nil)
    end)
  end)

# normalized_maps =
#  normalized_maps
#  |> Enum.filter(fn map -> Map.get(map, "country") != nil end)

Kino.DataTable.new(normalized_maps)
```

## Incident API

```elixir
alias Logpoint.Api
```

<!-- livebook:{"branch_parent_index":3} -->

## Getting the incidents within a specific time period

```elixir
{:ok, result} = Logpoint.incidents(pid, 1_714_100_000, :os.system_time(:millisecond))
```

<!-- livebook:{"branch_parent_index":3} -->

## Getting the incident states

```elixir
Logpoint.incident_states(pid, 1_714_100_000, :os.system_time(:millisecond))
```

<!-- livebook:{"branch_parent_index":3} -->

## Getting the data for a single incident

```elixir
{_, result} = Logpoint.incident(pid, "6628bcba248b50d05d38d23e", "84d77f5ea2801f9d9af6dc7ec77f6d3b")

Map.get(result, "rows")
|> Kino.DataTable.new()
```

<!-- livebook:{"branch_parent_index":3} -->

## Adding incident comments

```elixir
Logpoint.add_comments(pid, %{"6628bcba248b50d05d38d23e" => ["Test String"]})
```

<!-- livebook:{"branch_parent_index":3} -->

## Getting Incident Users and User Groups

```elixir
Logpoint.users(pid)
```

<!-- livebook:{"branch_parent_index":3} -->

## Assign Incident

```elixir
Logpoint.assign_incidents(pid, ["6628bcba248b50d05d38d23e"], "6576dedc81777a77c57723e5")
```

<!-- livebook:{"branch_parent_index":3} -->

## Resolve Incidents

```elixir
Logpoint.update_incidents(pid, :resolve, ["662ba226248b50d05d38d278"])
```

<!-- livebook:{"branch_parent_index":3} -->

## Close Incidents

```elixir
Logpoint.update_incidents(pid, :close, ["662ba226248b50d05d38d278"])
```

<!-- livebook:{"branch_parent_index":3} -->

## Reopen Incidents

```elixir
Logpoint.update_incidents(pid, :reopen, ["662ba226248b50d05d38d278"])
```

<!-- livebook:{"offset":5383,"stamp":{"token":"XCP.l34ga5peE_X18GbNBZilldYZFkA1fdXTGnA7lzb1O1CyVQNpqurVMaREqR2voU_-BLQmD0rMw0rbeWJ0Sng60eVQc76Eub9V7ons263-rK6hiN31k-_M","version":2}} -->
